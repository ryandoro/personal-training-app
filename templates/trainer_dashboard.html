{% extends "layout.html" %}

{% block title %}
    Trainer Dashboard
{% endblock %}

{% block content %}
<div class="trainer-dashboard-container container-fluid px-0 px-sm-3 px-lg-5">
    <div class="card w-100 shadow-sm p-0 border border-2 rounded-3 mb-4 trainer-dashboard-card" style="border-color: #ced4da;">
        <div class="card-body">
            <h2 class="card-header text-center text-white mb-4 p-3" style="background-color: #1EA4E6;">
                TRAINER DASHBOARD
            </h2>

            {% set add_client_url = url_for('add_client') %}
            {% set show_trainer_column = trainer.role == 'admin' %}

            <div class="d-flex flex-column align-items-center text-center gap-2 mb-4">
                <div>
                    <h3 class="mb-1">
                        {% set first_name = trainer.name or '' %}
                        {% set last_name = trainer.last_name or '' %}
                        {% if first_name or last_name %}
                            {{ first_name }} {{ last_name }}
                        {% else %}
                            {{ trainer.username }}
                        {% endif %}
                    </h3>
                    <p class="text-muted mb-0">Manage your clients and sessions at a glance.</p>
                </div>
            </div>

            <div class="row g-3 mb-4">
                <div class="col-md-6">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-body text-center">
                            <h5 class="card-title text-muted text-uppercase mb-2">Total Clients</h5>
                            <p class="display-6 fw-bold mb-0">{{ trainer_stats.total_clients or 0 }}</p>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-body text-center">
                            <h5 class="card-title text-muted text-uppercase mb-2">Sessions Completed</h5>
                            <p class="display-6 fw-bold mb-0">{{ trainer_stats.sessions_completed or 0 }}</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="d-flex flex-column flex-md-row align-items-md-center justify-content-between mb-4">
                <form method="GET" action="{{ url_for('trainer_dashboard') }}" class="d-flex flex-column flex-md-row gap-2 w-100 w-md-auto">
                    <div class="input-group">
                        <input type="text" name="search" class="form-control" placeholder="Search clients by name, username, or email" value="{{ search_term }}">
                        <button class="btn btn-brand-outline" type="submit">Search</button>
                    </div>
                </form>
                <div class="mt-3 mt-md-0 ms-md-3">
                    <a href="{{ add_client_url }}" class="btn btn-success w-100 w-md-auto">
                        <i class="bi bi-person-plus-fill me-1"></i>Add Client
                    </a>
                </div>
            </div>

            <div class="row g-3 mb-4 d-none">
                <div class="col-md-6">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-body text-center">
                            <h5 class="card-title text-muted text-uppercase mb-2">Total Clients</h5>
                            <p class="display-6 fw-bold mb-0">{{ trainer_stats.total_clients or 0 }}</p>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-body text-center">
                            <h5 class="card-title text-muted text-uppercase mb-2">Sessions Completed</h5>
                            <p class="display-6 fw-bold mb-0">{{ trainer_stats.sessions_completed or 0 }}</p>
                        </div>
                    </div>
                </div>
            </div>

            <form method="GET" action="{{ url_for('trainer_dashboard') }}" class="mb-4 d-none">
                <div class="input-group">
                    <input type="text" name="search" class="form-control" placeholder="Search clients by name, username, or email" value="{{ search_term }}">
                    <button class="btn btn-brand-outline" type="submit">Search</button>
                </div>
            </form>

            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    {% for category, message in messages %}
                        <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                            {{ message }}
                            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                        </div>
                    {% endfor %}
                {% endif %}
            {% endwith %}

            <div class="table-responsive">
                <table class="table table-bordered table-hover align-middle mt-2">
                    <thead class="table-light text-center">
                        <tr>
                            <th>First Name</th>
                            <th>Last Name</th>
                            <th>Workouts Completed</th>
                            <th>Sessions Booked</th>
                            <th>Sessions Completed</th>
                            <th>Sessions Left</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% if clients %}
                            {% for client in clients %}
                                <tr data-client-id="{{ client.id }}">
                                    {% set client_profile_url = url_for('client_profile', client_id=client.id) %}
                                    <td><a href="{{ client_profile_url }}" class="text-decoration-none">{{ client.name or '—' }}</a></td>
                                    <td><a href="{{ client_profile_url }}" class="text-decoration-none">{{ client.last_name or '—' }}</a></td>
                                    <td class="text-center workouts-completed-cell">{{ client.workouts_completed or 0 }}</td>
                                    <td class="text-center sessions-booked-cell">{{ client.sessions_booked or 0 }}</td>
                                    <td class="text-center sessions-completed-cell">{{ client.sessions_completed_count }}</td>
                                    <td class="text-center sessions-left-cell">
                                        {% if client.sessions_total is not none %}
                                            {{ client.sessions_left }} / {{ client.sessions_total }}
                                        {% else %}
                                            &infin;
                                        {% endif %}
                                    </td>
                                    <td class="text-center">
                                        <button type="button"
                                                class="btn btn-sm btn-outline-primary book-client-btn"
                                                data-client-id="{{ client.id }}"
                                                data-client-name="{{ client.name or client.username }}"
                                                data-client-lastname="{{ client.last_name or '' }}"
                                                data-sessions="{{ client.sessions_total if client.sessions_total is not none else '' }}"
                                                data-sessions-booked="{{ client.sessions_booked or 0 }}"
                                                data-sessions-completed="{{ client.sessions_completed_count }}"
                                                data-workouts-completed="{{ client.workouts_completed or 0 }}">
                                            Book Now
                                        </button>
                                    </td>
                                </tr>
                            {% endfor %}
                        {% else %}
                            <tr>
                                <td colspan="8" class="text-center text-muted">No clients assigned yet.</td>
                            </tr>
                        {% endif %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<div class="trainer-calendar-container container-fluid px-0 px-sm-3 px-lg-5">
    <div id="calendar-card" class="card border-0 shadow-lg mt-4 trainer-schedule-card mx-auto" style="border-radius: 20px;">
        <div class="card-header border-0 d-flex flex-column align-items-center text-center gap-3"
             style="background: linear-gradient(135deg, #1EA4E6 0%, #33C3F0 100%); border-top-left-radius: 20px; border-top-right-radius: 20px;">
            <div class="d-flex flex-column gap-3 text-white">
                <div>
                    <h4 class="mb-1 text-white">Weekly Schedule</h4>
                    <p class="mb-0 text-white-50">Plan sessions, drag to adjust, and stay aligned with your clients.</p>
                </div>
                <div class="d-flex flex-column align-items-center">
                    <div id="selected-client-pill" class="selected-client-pill selected-client-pill--empty mb-2" role="status" aria-live="polite">
                        <span class="selected-client-pill__label">Selected Client</span>
                        <span id="selected-client-display" class="selected-client-pill__name">No client selected</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="card-body">
            <div class="calendar-wrapper" id="trainer-calendar" data-mode="trainer"
                 data-view-start="{{ schedule_prefs.view_start }}" data-view-end="{{ schedule_prefs.view_end }}">
                <div class="calendar-controls">
                    <div class="calendar-controls__group">
                        <button class="btn btn-outline-secondary btn-sm w-100 calendar-controls__window" id="calendar-edit-window">
                            <i class="bi bi-sliders me-1"></i>Edit Available Window
                        </button>
                    </div>
                    <div class="calendar-controls__group">
                        <div class="calendar-view-toggle btn-group btn-group-sm w-100" role="group" aria-label="Calendar view mode">
                            <input type="radio" class="btn-check" name="calendar-view-mode" id="calendar-view-focused" autocomplete="off" checked>
                            <label class="btn btn-outline-primary" for="calendar-view-focused">Focused View</label>
                            <input type="radio" class="btn-check" name="calendar-view-mode" id="calendar-view-full" autocomplete="off">
                            <label class="btn btn-outline-primary" for="calendar-view-full">Full Week View</label>
                        </div>
                    </div>
                    <div class="calendar-controls__group">
                        <div class="calendar-week-label fw-semibold" id="calendar-week-label"></div>
                    </div>
                    <div class="calendar-controls__group">
                        <div class="calendar-controls__nav btn-group w-100" role="group" aria-label="Calendar navigation">
                            <button class="btn btn-outline-primary btn-sm flex-fill calendar-controls__button" id="calendar-prev-week" aria-label="Previous week">
                                <i class="bi bi-chevron-left"></i>
                            </button>
                            <button class="btn btn-primary btn-sm flex-fill calendar-controls__button calendar-controls__button--today" id="calendar-today">
                                Today
                            </button>
                            <button class="btn btn-outline-primary btn-sm flex-fill calendar-controls__button" id="calendar-next-week" aria-label="Next week">
                                <i class="bi bi-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="calendar-scroll" id="calendar-scroll">
                    <div class="calendar-header" id="calendar-days-header"></div>
                    <div class="calendar-grid">
                        <div class="calendar-times" id="calendar-times"></div>
                        <div class="calendar-columns" id="calendar-day-columns"></div>
                    </div>
                </div>
                <div class="calendar-empty-state" id="calendar-empty-state" hidden>
                    <p class="mb-0">Select a client to begin scheduling.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="trainer-timeoff-container container-fluid px-0 px-sm-3 px-lg-5">
    <div class="card border-0 shadow-sm mt-4 mb-5 timeoff-card mx-auto" style="border-radius: 18px;">
        <div class="card-body p-4">
            <div class="d-flex flex-column flex-lg-row justify-content-between align-items-lg-center mb-3 gap-3">
                <div>
                    <h5 class="mb-1 text-primary fw-semibold">Personal Time Blocks</h5>
                    <p class="mb-0 text-muted small">Add time you are unavailable inside your availability window. Blocks appear on the calendar and sessions cannot overlap them.</p>
                </div>
                <div class="badge bg-warning-subtle text-warning-emphasis d-flex align-items-center gap-2 fw-semibold px-3 py-2">
                    <i class="bi bi-umbrella-fill"></i>
                    Personal Time
                </div>
            </div>
            <form id="timeOffForm" class="row g-3 align-items-end" novalidate>
                <div class="col-12 col-md-6 col-lg-4">
                    <label for="timeOffStart" class="form-label small text-uppercase text-muted">Start</label>
                    <input type="datetime-local" class="form-control" id="timeOffStart" step="900" required>
                </div>
                <div class="col-12 col-md-6 col-lg-4">
                    <label for="timeOffEnd" class="form-label small text-uppercase text-muted">End</label>
                    <input type="datetime-local" class="form-control" id="timeOffEnd" step="900" required>
                </div>
                <div class="col-12 col-lg-4 d-flex align-items-end">
                    <button type="submit" class="btn btn-warning w-100 fw-semibold" id="timeOffSubmit">
                        <i class="bi bi-calendar-plus me-1"></i>Block Personal Time
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<div id="windowModal" class="calendar-modal" hidden>
    <div class="calendar-modal-content">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h5 class="mb-0">Edit Visible Hours</h5>
            <button type="button" class="btn-close" id="windowModalClose"></button>
        </div>
        <form id="windowForm" class="row g-3">
            <div class="col-6">
                <label for="windowStart" class="form-label">Start hour</label>
                <input type="time" class="form-control" id="windowStart" step="900" value="05:00">
            </div>
            <div class="col-6">
                <label for="windowEnd" class="form-label">End hour</label>
                <input type="time" class="form-control" id="windowEnd" step="900" value="21:00">
            </div>
            <div class="col-12 text-end">
                <button type="button" class="btn btn-outline-secondary me-2" id="windowCancel">Cancel</button>
                <button type="submit" class="btn btn-primary">Apply</button>
            </div>
        </form>
    </div>
</div>

<div id="eventModal" class="calendar-modal" hidden>
    <div class="calendar-modal-content event-session-modal">
        <div class="event-session-modal__header">
            <div>
                <span class="event-session-modal__status" id="eventModalStatus">Booked</span>
                <h4 class="event-session-modal__title" id="eventModalTitle">Session Details</h4>
                <div class="event-session-modal__time" id="eventModalTime"></div>
            </div>
            <button type="button" class="btn-close btn-close-white" id="eventModalClose" aria-label="Close"></button>
        </div>
        <div class="event-session-modal__body">
            <button type="button" class="btn btn-outline-primary w-100" id="eventViewProfile">
                <i class="bi bi-person-bounding-box me-1"></i>View Client Profile
            </button>

            <div class="event-session-modal__section">
                <label for="eventStatusSelect" class="form-label small text-uppercase text-muted">Session Status</label>
                <form id="eventStatusForm" class="event-session-modal__inline" novalidate>
                    <select class="form-select" id="eventStatusSelect">
                        <option value="booked">Booked</option>
                        <option value="completed">Completed</option>
                        <option value="cancelled">Cancelled</option>
                    </select>
                    <button type="submit" class="btn btn-primary" id="eventStatusUpdate">
                        <i class="bi bi-check2-circle me-1"></i>Apply
                    </button>
                </form>
                <div class="form-text" id="eventStatusInfo">Status changes update client balances immediately.</div>
            </div>

            <div class="event-session-modal__section" id="eventRepeatSection">
                <label for="eventRepeatWeeks" class="form-label small text-uppercase text-muted">Repeat Weekly</label>
                <form id="eventRepeatForm" class="event-session-modal__inline" novalidate>
                    <input type="number" class="form-control" id="eventRepeatWeeks" min="1" max="52" step="1" inputmode="numeric" placeholder="Enter weeks to repeat">
                    <button type="submit" class="btn btn-outline-primary" id="eventRepeatSubmit">
                        <i class="bi bi-arrow-repeat me-1"></i>Repeat
                    </button>
                </form>
                <div class="form-text" id="eventRepeatInfo">Repeats will use available sessions remaining.</div>
            </div>
        </div>
        <div class="event-session-modal__footer">
            <button type="button" class="btn btn-danger w-100" id="eventDeleteSession">
                <i class="bi bi-trash me-1"></i>Delete Session
            </button>
        </div>
    </div>
</div>

<template id="calendar-event-template">
    <div class="calendar-event" draggable="false">
        <div class="calendar-event-dragzone">
            <i class="bi bi-grip-horizontal calendar-event-dragicon" aria-hidden="true"></i>
            <span class="calendar-event-dragtext">Drag to Move</span>
        </div>
        <div class="calendar-event-content">
            <div class="calendar-event-title"></div>
            <div class="calendar-event-time"></div>
        </div>
        <div class="calendar-event-handle calendar-event-handle-top"></div>
        <div class="calendar-event-handle calendar-event-handle-bottom"></div>
    </div>
</template>

<script>
(function(){
    const calendarRoot = document.getElementById('trainer-calendar');
    if (!calendarRoot) return;

    const dayHeaderEl = document.getElementById('calendar-days-header');
    const timesEl = document.getElementById('calendar-times');
    const columnsEl = document.getElementById('calendar-day-columns');
    const emptyState = document.getElementById('calendar-empty-state');
    const weekLabel = document.getElementById('calendar-week-label');
    const displaySelected = document.getElementById('selected-client-display');
    const selectedClientPill = document.getElementById('selected-client-pill');
    const prevWeekBtn = document.getElementById('calendar-prev-week');
    const nextWeekBtn = document.getElementById('calendar-next-week');
    const todayBtn = document.getElementById('calendar-today');
    const editWindowBtn = document.getElementById('calendar-edit-window');
    const viewToggleFocused = document.getElementById('calendar-view-focused');
    const viewToggleFull = document.getElementById('calendar-view-full');
    const windowModal = document.getElementById('windowModal');
    const windowModalClose = document.getElementById('windowModalClose');
    const windowCancel = document.getElementById('windowCancel');
    const windowForm = document.getElementById('windowForm');
    const windowStartInput = document.getElementById('windowStart');
    const windowEndInput = document.getElementById('windowEnd');
    const eventTemplate = document.getElementById('calendar-event-template');
    const bookButtons = document.querySelectorAll('.book-client-btn');
    const eventModal = document.getElementById('eventModal');
    const eventModalClose = document.getElementById('eventModalClose');
    const eventModalTitle = document.getElementById('eventModalTitle');
    const eventModalTime = document.getElementById('eventModalTime');
    const eventModalStatus = document.getElementById('eventModalStatus');
    const eventViewProfileBtn = document.getElementById('eventViewProfile');
    const eventRepeatForm = document.getElementById('eventRepeatForm');
    const eventRepeatWeeksInput = document.getElementById('eventRepeatWeeks');
    const eventRepeatInfo = document.getElementById('eventRepeatInfo');
    const eventRepeatSubmit = document.getElementById('eventRepeatSubmit');
    const eventRepeatSection = document.getElementById('eventRepeatSection');
    const eventStatusForm = document.getElementById('eventStatusForm');
    const eventStatusSelect = document.getElementById('eventStatusSelect');
    const eventStatusUpdate = document.getElementById('eventStatusUpdate');
    const eventStatusInfo = document.getElementById('eventStatusInfo');
    const eventDeleteSession = document.getElementById('eventDeleteSession');
    const eventStatusSection = eventStatusForm ? eventStatusForm.closest('.event-session-modal__section') : null;
    const timeOffForm = document.getElementById('timeOffForm');
    const timeOffStartInput = document.getElementById('timeOffStart');
    const timeOffEndInput = document.getElementById('timeOffEnd');
    const timeOffSubmit = document.getElementById('timeOffSubmit');
    const clientProfileBase = "{{ url_for('client_profile', client_id=0)[:-1] }}";
    const eventRepeatSubmitDefault = eventRepeatSubmit ? eventRepeatSubmit.innerHTML : '';
    const eventStatusUpdateDefault = eventStatusUpdate ? eventStatusUpdate.innerHTML : '';
    const eventDeleteDefault = eventDeleteSession ? eventDeleteSession.innerHTML : '';
    const globalToast = document.getElementById('globalToast');
    const toastMessageEl = document.getElementById('toastMessage');
    const toastVariants = ['toast-success', 'toast-warning', 'toast-danger', 'toast-info'];
    let toastTimeout = null;

    if (eventRepeatWeeksInput) {
        const sanitizeRepeatWeeks = () => {
            const raw = (eventRepeatWeeksInput.value || '').trim();
            if (!raw) {
                eventRepeatWeeksInput.value = '';
                return;
            }
            let numeric = raw.replace(/[^0-9]/g, '');
            if (numeric !== raw) {
                eventRepeatWeeksInput.value = numeric;
            }
            if (!numeric) return;
            let value = Number(numeric);
            if (!Number.isFinite(value)) {
                eventRepeatWeeksInput.value = '';
                return;
            }
            value = Math.floor(value);
            if (value < 1) value = 1;
            if (value > 52) value = 52;
            eventRepeatWeeksInput.value = String(value);
        };
        eventRepeatWeeksInput.addEventListener('input', () => {
            const raw = eventRepeatWeeksInput.value || '';
            const digits = raw.replace(/[^0-9]/g, '');
            if (raw !== digits) {
                eventRepeatWeeksInput.value = digits;
            }
        });
        eventRepeatWeeksInput.addEventListener('change', sanitizeRepeatWeeks);
        eventRepeatWeeksInput.addEventListener('blur', sanitizeRepeatWeeks);
        eventRepeatWeeksInput.addEventListener('keydown', (evt) => {
            if (['e', 'E', '+', '-', '.', ','].includes(evt.key)) {
                evt.preventDefault();
            }
        });
    }

    function setSelectedClientDisplay(message, isEmpty = false) {
        if (displaySelected) {
            displaySelected.textContent = message;
        }
        if (selectedClientPill) {
            selectedClientPill.classList.toggle('selected-client-pill--empty', Boolean(isEmpty));
        }
    }

    const VIEW_MODE_STORAGE_KEY = 'trainerCalendarViewMode';

    function loadStoredViewMode() {
        try {
            if (typeof window === 'undefined' || !window.localStorage) return null;
            const stored = window.localStorage.getItem(VIEW_MODE_STORAGE_KEY);
            if (stored === 'full' || stored === 'focused') {
                return stored;
            }
        } catch (_) {}
        return null;
    }

    function persistViewMode(mode) {
        try {
            if (typeof window === 'undefined' || !window.localStorage) return;
            window.localStorage.setItem(VIEW_MODE_STORAGE_KEY, mode);
        } catch (_) {}
    }

    const datasetStart = Number(calendarRoot.dataset.viewStart);
    const datasetEnd = Number(calendarRoot.dataset.viewEnd);
    let initialStart = Number.isFinite(datasetStart) ? datasetStart : 5;
    let initialEnd = Number.isFinite(datasetEnd) ? datasetEnd : 21;
    if (initialEnd <= initialStart) {
        initialStart = 5;
        initialEnd = 21;
    }
    const storedMode = loadStoredViewMode();
    const initialMode = storedMode || 'focused';

    const FIFTEEN_MINUTES = 15;
    const DEFAULT_DURATION = 60;
    const MILLI_IN_MINUTE = 60000;
    const HOLD_TO_DRAG_DELAY = 350;
    const HOLD_MOVE_TOLERANCE = 6;

    const state = {
        selectedClient: null,
        selectedClientButton: null,
        weekStart: startOfWeek(new Date()),
        viewStart: initialStart,
        viewEnd: initialEnd,
        viewMode: initialMode,
        events: [],
        dragging: null,
        dragPointer: null,
        modalEvent: null,
        justDragged: false,
        dragHoldInfo: null,
        dragHoldTimer: null
    };

    updateViewToggleUI(initialMode);
    calendarRoot.classList.toggle('calendar-mode-full', initialMode === 'full');
    persistViewMode(initialMode);

    let dayColumns = [];

    const STATUS_LABELS = {
        booked: 'Booked',
        completed: 'Completed',
        cancelled: 'Cancelled',
        time_off: 'Personal Time'
    };

    function eventKey(eventData) {
        if (!eventData || typeof eventData.id === 'undefined') return null;
        const group = eventData.type || (eventData.status === 'time_off' ? 'time_off' : 'session');
        return `${group}:${eventData.id}`;
    }

    function getEntryType(entry) {
        if (!entry) return 'session';
        return entry.type || (entry.status === 'time_off' ? 'time_off' : 'session');
    }

    function hasBlockingConflict(start, end, entryType, excludeKey = null) {
        if (!start || !end) return false;
        return state.events.some(existing => {
            if (!existing || !existing.start_time || !existing.end_time) return false;
            const key = eventKey(existing);
            if (excludeKey && key === excludeKey) return false;
            const existingStart = new Date(existing.start_time);
            const existingEnd = new Date(existing.end_time);
            if (!rangesOverlap(start, end, existingStart, existingEnd)) return false;
            const existingType = getEntryType(existing);
            if (entryType === 'time_off' || existingType === 'time_off') {
                return true;
            }
            return true;
        });
    }

    function handleDragPointerDown(evt, eventData, column) {
        cancelHoldToDrag();
        if (!evt || !eventData || !column) return;
        const pointerType = evt.pointerType || 'mouse';
        if (pointerType === 'mouse') {
            if (typeof evt.button !== 'undefined' && evt.button !== 0) return;
            beginDrag(evt, eventData, column);
            return;
        }
        startHoldToDrag(evt, eventData, column);
    }

    function startHoldToDrag(evt, eventData, column) {
        const dragZone = evt.currentTarget || evt.target;
        if (!dragZone) return;
        state.dragHoldInfo = {
            pointerId: evt.pointerId,
            startX: evt.clientX,
            startY: evt.clientY,
            eventData,
            column,
            dragZone,
            lastEvent: evt,
            triggerEvent: evt
        };
        state.dragHoldTimer = setTimeout(triggerHoldDrag, HOLD_TO_DRAG_DELAY);
        document.addEventListener('pointermove', handleHoldPointerMove, { passive: true });
        document.addEventListener('pointerup', cancelHoldToDrag);
        document.addEventListener('pointercancel', cancelHoldToDrag);
    }

    function handleHoldPointerMove(evt) {
        const info = state.dragHoldInfo;
        if (!info || evt.pointerId !== info.pointerId) return;
        info.lastEvent = evt;
        if (!state.dragHoldTimer) return;
        const dx = Math.abs(evt.clientX - info.startX);
        const dy = Math.abs(evt.clientY - info.startY);
        if (dx > HOLD_MOVE_TOLERANCE || dy > HOLD_MOVE_TOLERANCE) {
            cancelHoldToDrag();
        }
    }

    function cancelHoldToDrag(evt) {
        const info = state.dragHoldInfo;
        if (evt && info && typeof evt.pointerId !== 'undefined' && evt.pointerId !== info.pointerId) {
            return;
        }
        if (state.dragHoldTimer) {
            clearTimeout(state.dragHoldTimer);
            state.dragHoldTimer = null;
        }
        document.removeEventListener('pointermove', handleHoldPointerMove);
        document.removeEventListener('pointerup', cancelHoldToDrag);
        document.removeEventListener('pointercancel', cancelHoldToDrag);
        state.dragHoldInfo = null;
    }

    function triggerHoldDrag() {
        const info = state.dragHoldInfo;
        state.dragHoldTimer = null;
        document.removeEventListener('pointermove', handleHoldPointerMove);
        document.removeEventListener('pointerup', cancelHoldToDrag);
        document.removeEventListener('pointercancel', cancelHoldToDrag);
        if (!info) return;
        const syntheticEvent = {
            clientX: info.lastEvent?.clientX ?? info.startX,
            clientY: info.lastEvent?.clientY ?? info.startY,
            pointerId: info.pointerId,
            target: info.dragZone,
            currentTarget: info.dragZone,
            preventDefault: () => {
                if (info.triggerEvent && typeof info.triggerEvent.preventDefault === 'function') {
                    info.triggerEvent.preventDefault();
                }
            }
        };
        beginDrag(syntheticEvent, info.eventData, info.column);
        state.dragHoldInfo = null;
    }

    function startOfWeek(date) {
        const d = new Date(date);
        const day = d.getDay();
        const diff = d.getDate() - day + (day === 0 ? -6 : 1);
        d.setDate(diff);
        d.setHours(0,0,0,0);
        return d;
    }

    function showDashboardToast(message, variant = 'success') {
        if (!globalToast || !toastMessageEl) {
            alert(message);
            return;
        }
        toastMessageEl.textContent = message;
        toastVariants.forEach(cls => globalToast.classList.remove(cls));
        const className = `toast-${variant}`;
        globalToast.classList.add(className);
        globalToast.style.display = 'block';
        if (toastTimeout) clearTimeout(toastTimeout);
        if (variant !== 'danger') {
            toastTimeout = setTimeout(() => {
                globalToast.style.display = 'none';
            }, 4000);
        }
    }

    function updateClientRowCounts(clientId, totalSessions, bookedSessions, completedSessions = 0, workoutsCompleted = null) {
        const row = document.querySelector(`tr[data-client-id="${clientId}"]`);
        if (!row) return;
        const workoutsCell = row.querySelector('.workouts-completed-cell');
        const bookedCell = row.querySelector('.sessions-booked-cell');
        const completedCell = row.querySelector('.sessions-completed-cell');
        const leftCell = row.querySelector('.sessions-left-cell');
        if (workoutsCell && workoutsCompleted !== null && typeof workoutsCompleted !== 'undefined') {
            workoutsCell.textContent = workoutsCompleted;
        }
        if (bookedCell) {
            bookedCell.textContent = bookedSessions;
        }
        if (completedCell) {
            completedCell.textContent = completedSessions;
        }
        if (leftCell) {
            if (totalSessions === null || totalSessions === undefined || totalSessions === '') {
                leftCell.textContent = '∞';
            } else {
                const consumed = Math.min(totalSessions, Math.max(bookedSessions, 0) + Math.max(completedSessions, 0));
                const left = Math.max(totalSessions - consumed, 0);
                leftCell.textContent = `${left} / ${totalSessions}`;
            }
        }
    }

    function upsertEvent(eventData) {
        if (!eventData) return;
        if (!eventData.type) {
            eventData.type = eventData.status === 'time_off' ? 'time_off' : 'session';
        }
        if (eventData.type === 'time_off') {
            eventData.status = 'time_off';
            eventData.title = eventData.title || 'Personal Time';
        } else {
            eventData.status = String(eventData.status || 'booked').toLowerCase();
        }
        const key = eventKey(eventData);
        if (!key) return;
        const idx = state.events.findIndex(ev => eventKey(ev) === key);
        if (idx !== -1) {
            state.events[idx] = { ...state.events[idx], ...eventData };
        } else {
            state.events.push(eventData);
        }
    }

    function sortEvents() {
        state.events.sort((a, b) => {
            const aStart = a?.start_time ? new Date(a.start_time).getTime() : 0;
            const bStart = b?.start_time ? new Date(b.start_time).getTime() : 0;
            return aStart - bStart;
        });
    }

    function syncClientSessionCounts(clientId, counts = {}) {
        const {
            sessions_booked: bookedValue,
            sessions_remaining: totalValue,
            sessions_completed: completedValue,
            workouts_completed: workoutsValue
        } = counts;

        const button = document.querySelector(`.book-client-btn[data-client-id="${clientId}"]`);
        let totalSessions = totalValue;
        let workoutsCompleted = workoutsValue;

        if (button) {
            if (totalValue !== undefined) {
                if (totalValue === null || totalValue === '') {
                    button.dataset.sessions = '';
                    totalSessions = null;
                } else {
                    button.dataset.sessions = String(totalValue);
                    totalSessions = Number(totalValue);
                }
            } else {
                totalSessions = button.dataset.sessions === '' ? null : Number(button.dataset.sessions || '0');
            }
            if (workoutsValue !== undefined && workoutsValue !== null) {
                button.dataset.workoutsCompleted = String(workoutsValue);
            }

            if (bookedValue !== undefined && bookedValue !== null) {
                button.dataset.sessionsBooked = String(bookedValue);
            }
            if (completedValue !== undefined && completedValue !== null) {
                button.dataset.sessionsCompleted = String(completedValue);
            }
        } else if (totalSessions === undefined) {
            totalSessions = null;
        }

        const datasetWorkouts = button ? Number(button.dataset.workoutsCompleted || '0') : 0;
        const datasetBooked = button ? Number(button.dataset.sessionsBooked || '0') : 0;
        const datasetCompleted = button ? Number(button.dataset.sessionsCompleted || '0') : 0;
        const bookedSessions = bookedValue !== undefined && bookedValue !== null
            ? Number(bookedValue)
            : (state.selectedClient && state.selectedClient.id === clientId ? state.selectedClient.sessionsBooked || 0 : datasetBooked);
        const completedSessions = completedValue !== undefined && completedValue !== null
            ? Number(completedValue)
            : (state.selectedClient && state.selectedClient.id === clientId ? state.selectedClient.sessionsCompleted || 0 : datasetCompleted);
        workoutsCompleted = workoutsValue !== undefined && workoutsValue !== null
            ? Number(workoutsValue)
            : (state.selectedClient && state.selectedClient.id === clientId && typeof state.selectedClient.workoutsCompleted !== 'undefined'
                ? state.selectedClient.workoutsCompleted
                : datasetWorkouts);

        updateClientRowCounts(clientId, totalSessions, bookedSessions, completedSessions, workoutsCompleted);

        if (state.selectedClient && state.selectedClient.id === clientId) {
            if (bookedValue !== undefined && bookedValue !== null) {
                state.selectedClient.sessionsBooked = Number(bookedValue);
                if (state.selectedClientButton) {
                    state.selectedClientButton.dataset.sessionsBooked = String(bookedValue);
                }
            }
            if (completedValue !== undefined && completedValue !== null) {
                state.selectedClient.sessionsCompleted = Number(completedValue);
                if (state.selectedClientButton) {
                    state.selectedClientButton.dataset.sessionsCompleted = String(completedValue);
                }
            }
            if (totalValue !== undefined) {
                state.selectedClient.sessions = totalSessions;
                if (state.selectedClientButton) {
                    state.selectedClientButton.dataset.sessions = totalSessions === null ? '' : String(totalSessions);
                }
            }
            if (workoutsCompleted !== undefined && workoutsCompleted !== null) {
                state.selectedClient.workoutsCompleted = workoutsCompleted;
                if (state.selectedClientButton) {
                    state.selectedClientButton.dataset.workoutsCompleted = String(workoutsCompleted);
                }
            }
        }
    }

    function ensureClientSelection(clientId) {
        if (!clientId) return;
        if (state.selectedClient && state.selectedClient.id === clientId) return;
        const button = document.querySelector(`.book-client-btn[data-client-id="${clientId}"]`);
        if (!button) return;
        bookButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        const name = button.dataset.clientName || 'Client';
        const last = button.dataset.clientLastname || '';
        const fullName = `${name} ${last}`.trim();
        setSelectedClientDisplay(`Booking for ${fullName}`, false);
        const sessionsTotal = button.dataset.sessions === '' ? null : Number(button.dataset.sessions || '0');
        const sessionsBooked = Number(button.dataset.sessionsBooked || '0');
        const sessionsCompleted = Number(button.dataset.sessionsCompleted || '0');
        const workoutsCompleted = Number(button.dataset.workoutsCompleted || '0');
        state.selectedClient = {
            id: Number(button.dataset.clientId),
            name,
            last,
            sessions: sessionsTotal,
            sessionsBooked,
            sessionsCompleted,
            workoutsCompleted
        };
        state.selectedClientButton = button;
    }

    function applyStatusBadge(status) {
        if (!eventModalStatus) return;
        const normalized = (status || 'booked').toLowerCase();
        const label = STATUS_LABELS[normalized] || 'Booked';
        eventModalStatus.textContent = label;
        eventModalStatus.className = 'event-session-modal__status';
        if (normalized === 'time_off') {
            eventModalStatus.classList.add('status-pill--timeoff');
        } else if (normalized === 'completed') {
            eventModalStatus.classList.add('status-pill--completed');
        } else if (normalized === 'cancelled') {
            eventModalStatus.classList.add('status-pill--cancelled');
        } else {
            eventModalStatus.classList.add('status-pill--booked');
        }
    }

    function refreshModalFromState() {
        if (!state.modalEvent) return;
        const modalData = state.modalEvent;
        const eventType = modalData.type || 'session';
        const status = (modalData.status || 'booked').toLowerCase();
        const start = new Date(modalData.start_time);
        const end = new Date(modalData.end_time);
        if (eventModalTitle) {
            if (eventType === 'time_off') {
                eventModalTitle.textContent = modalData.title || 'Personal Time';
            } else {
                const fullName = modalData.client_name ? `${modalData.client_name} ${modalData.client_last_name || ''}`.trim() : modalData.client_username;
                eventModalTitle.textContent = fullName || 'Client Session';
            }
        }
        if (eventModalTime) {
            const dateStr = start.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric' });
            eventModalTime.textContent = `${dateStr} · ${formatTime(start)} – ${formatTime(end)}`;
        }
        const badgeStatus = eventType === 'time_off' ? 'time_off' : status;
        applyStatusBadge(badgeStatus);

        const repeatHidden = status === 'cancelled';
        if (eventRepeatForm) {
            eventRepeatForm.hidden = repeatHidden;
        }
        if (eventRepeatSection) {
            eventRepeatSection.hidden = repeatHidden;
        }
        if (eventRepeatInfo) {
            if (status === 'cancelled') {
                eventRepeatInfo.textContent = 'This session has been cancelled.';
            } else if (modalData.repeatInfo) {
                eventRepeatInfo.textContent = modalData.repeatInfo;
            } else if (eventType === 'time_off') {
                eventRepeatInfo.textContent = 'Repeats will create additional personal time blocks on future weeks.';
            } else {
                eventRepeatInfo.textContent = 'Repeats will use available sessions remaining.';
            }
        }

        if (eventRepeatSubmit) {
            eventRepeatSubmit.disabled = false;
            eventRepeatSubmit.innerHTML = eventRepeatSubmitDefault;
        }

        if (eventStatusSelect) {
            eventStatusSelect.value = eventType === 'time_off' ? 'booked' : status;
        }
        if (eventStatusInfo) {
            eventStatusInfo.textContent = eventType === 'time_off'
                ? 'Personal time blocks prevent new sessions during this window.'
                : 'Status changes update client balances immediately.';
        }
        if (eventStatusUpdate) {
            eventStatusUpdate.disabled = false;
            eventStatusUpdate.innerHTML = eventStatusUpdateDefault;
        }
        if (eventStatusSection) {
            eventStatusSection.hidden = eventType === 'time_off';
        }
        if (eventViewProfileBtn) {
            if (eventType === 'time_off') {
                eventViewProfileBtn.hidden = true;
                eventViewProfileBtn.onclick = null;
            } else {
                eventViewProfileBtn.hidden = false;
                eventViewProfileBtn.onclick = () => {
                    const targetId = modalData.client_id;
                    window.location.href = `${clientProfileBase}${targetId}`;
                };
            }
        }
        if (eventDeleteSession) {
            if (eventType === 'time_off') {
                eventDeleteSession.innerHTML = '<i class="bi bi-trash me-1"></i>Delete Time Off';
            } else {
                eventDeleteSession.innerHTML = eventDeleteDefault;
            }
            eventDeleteSession.disabled = false;
        }
    }

    function openEventModal(eventData) {
        if (!eventModal || !eventData) return;
        const eventType = eventData.type || (eventData.status === 'time_off' ? 'time_off' : 'session');
        if (eventType !== 'time_off') {
            ensureClientSelection(eventData.client_id);
        }
        state.modalEvent = {
            ...eventData,
            type: eventType,
            status: eventType === 'time_off'
                ? 'time_off'
                : (eventData.status || 'booked').toLowerCase()
        };
        state.modalEvent.repeatInfo = undefined;
        if (eventDeleteSession) {
            eventDeleteSession.disabled = false;
            eventDeleteSession.innerHTML = eventDeleteDefault;
        }
        refreshModalFromState();
        if (eventRepeatWeeksInput) {
            eventRepeatWeeksInput.value = '';
        }
        if (eventRepeatSubmit) {
            eventRepeatSubmit.disabled = false;
            eventRepeatSubmit.innerHTML = eventRepeatSubmitDefault;
        }
        state.justDragged = false;
        eventModal.hidden = false;
    }

    function closeEventModal() {
        if (!eventModal) return;
        eventModal.hidden = true;
        if (eventRepeatSubmit) {
            eventRepeatSubmit.disabled = false;
            eventRepeatSubmit.innerHTML = eventRepeatSubmitDefault;
        }
        if (eventStatusUpdate) {
            eventStatusUpdate.disabled = false;
            eventStatusUpdate.innerHTML = eventStatusUpdateDefault;
        }
        if (eventDeleteSession) {
            eventDeleteSession.disabled = false;
            eventDeleteSession.innerHTML = eventDeleteDefault;
        }
        state.modalEvent = null;
    }

    function handleEventClick(evt, eventData) {
        if (evt) {
            evt.stopPropagation();
            if (evt.target && evt.target.closest('.calendar-event-handle')) return;
            if (typeof evt.button === 'number' && evt.button !== 0) return;
        }
        if (state.dragging) return;
        if (state.justDragged) {
            state.justDragged = false;
            return;
        }
        openEventModal(eventData);
    }


    function formatDayParts(date) {
        return {
            weekday: date.toLocaleDateString(undefined, { weekday: 'short' }),
            month: date.toLocaleDateString(undefined, { month: 'short' }),
            day: date.toLocaleDateString(undefined, { day: 'numeric' })
        };
    }

    function toISODate(date) {
        const copy = new Date(date);
        return copy.toISOString();
    }

    function clampHour(value) {
        return Math.min(24, Math.max(0, value));
    }

    function updateViewToggleUI(mode = state.viewMode) {
        if (viewToggleFocused) {
            viewToggleFocused.checked = mode === 'focused';
        }
        if (viewToggleFull) {
            viewToggleFull.checked = mode === 'full';
        }
    }

    function applyViewMode(mode, options = {}) {
        const { force = false } = options;
        if (!force && state.viewMode === mode) {
            updateViewToggleUI(mode);
            return;
        }
        state.viewMode = mode;
        calendarRoot.classList.toggle('calendar-mode-full', mode === 'full');
        updateViewToggleUI(mode);
        persistViewMode(mode);
        rebuildGrid();
        renderEvents();
    }

    function updateWeekLabel() {
        const end = new Date(state.weekStart);
        end.setDate(end.getDate() + 6);
        const startYear = state.weekStart.getFullYear();
        const endYear = end.getFullYear();
        if (startYear === endYear) {
            const startText = state.weekStart.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
            const endText = end.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
            weekLabel.textContent = `${startText} – ${endText}, ${startYear}`;
        } else {
            const startText = state.weekStart.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
            const endText = end.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
            weekLabel.textContent = `${startText} – ${endText}`;
        }
    }

    function renderHeaders() {
        dayHeaderEl.innerHTML = '';
        columnsEl.innerHTML = '';
        dayColumns = [];

        const spacer = document.createElement('div');
        spacer.className = 'calendar-time-spacer';
        dayHeaderEl.appendChild(spacer);

        for (let i = 0; i < 7; i += 1) {
            const dayDate = new Date(state.weekStart);
            dayDate.setDate(dayDate.getDate() + i);

            const header = document.createElement('div');
            header.className = 'calendar-day-header';
            header.dataset.date = dayDate.toISOString();
            const { weekday, month, day } = formatDayParts(dayDate);
            header.innerHTML = `<span class="calendar-day-label">${weekday}</span><span class="calendar-date-label">${month}, ${day}</span>`;
            dayHeaderEl.appendChild(header);

            const col = document.createElement('div');
            col.className = 'calendar-day-column';
            col.dataset.date = dayDate.toISOString();
            columnsEl.appendChild(col);
            dayColumns.push(col);
        }
    }

    function renderTimes() {
        timesEl.innerHTML = '';
        const total = (state.viewEnd - state.viewStart) * 4;
        for (let i = 0; i < total; i += 1) {
            const slotHour = state.viewStart + Math.floor(i / 4);
            const slotMinutes = (i % 4) * 15;
            const time = document.createElement('div');
            time.className = 'calendar-time-label';
            if (slotMinutes === 0) {
                const label = new Date();
                label.setHours(slotHour, slotMinutes, 0, 0);
                time.textContent = label.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            }
            timesEl.appendChild(time);
        }
    }

    function renderSlots() {
        const totalSlots = (state.viewEnd - state.viewStart) * 4;
        const now = new Date();
        dayColumns.forEach((column, index) => {
            column.innerHTML = '';
            const date = new Date(state.weekStart);
            date.setDate(date.getDate() + index);

            for (let i = 0; i < totalSlots; i += 1) {
                const slot = document.createElement('div');
                slot.className = 'calendar-slot';
                const slotHour = state.viewStart + Math.floor(i / 4);
                const slotMinutes = (i % 4) * 15;
                const slotDate = new Date(date);
                slotDate.setHours(slotHour, slotMinutes, 0, 0);
                slot.dataset.start = slotDate.toISOString();
                if (slotDate < now) {
                    slot.classList.add('calendar-slot-past');
                }
                column.appendChild(slot);
            }
        });
    }

    function renderEvents() {
        dayColumns.forEach(col => col.querySelectorAll('.calendar-event').forEach(el => el.remove()));
        if (state.events.length === 0) {
            if (state.selectedClient) {
                emptyState.hidden = false;
                emptyState.textContent = 'Tap a time slot to schedule their next session.';
            } else {
                emptyState.hidden = false;
                emptyState.textContent = 'Select a client to begin scheduling.';
            }
        } else {
            emptyState.hidden = true;
        }

        state.events.forEach(event => {
            const start = new Date(event.start_time);
            const end = new Date(event.end_time);
            const dayIndex = Math.floor((start - state.weekStart) / (24 * 60 * 60 * 1000));
            if (dayIndex < 0 || dayIndex >= dayColumns.length) return;
            const column = dayColumns[dayIndex];
            const totalMinutes = (state.viewEnd - state.viewStart) * 60;
            const eventStartMinutes = start.getHours() * 60 + start.getMinutes();
            const eventEndMinutes = end.getHours() * 60 + end.getMinutes();
            const windowStart = state.viewStart * 60;
            const windowEnd = state.viewEnd * 60;
            const visibleStart = Math.max(windowStart, eventStartMinutes);
            const visibleEnd = Math.min(windowEnd, eventEndMinutes);
            if (visibleEnd <= windowStart || visibleStart >= windowEnd) return;
            const top = ((visibleStart - windowStart) / totalMinutes) * 100;
            const durationVisible = Math.max(FIFTEEN_MINUTES, visibleEnd - visibleStart);
            const height = (durationVisible / totalMinutes) * 100;

            const eventNode = eventTemplate.content.firstElementChild.cloneNode(true);
            eventNode.dataset.id = event.id;
            const eventType = event.type || (event.status === 'time_off' ? 'time_off' : 'session');
            eventNode.dataset.type = eventType;
            const isTimeOff = eventType === 'time_off';
            eventNode.dataset.clientId = isTimeOff ? '' : (event.client_id ?? '');
            const status = isTimeOff ? 'time_off' : (event.status || 'booked').toLowerCase();
            eventNode.dataset.status = status;
            eventNode.classList.toggle('calendar-event-cancelled', !isTimeOff && status === 'cancelled');
            eventNode.classList.toggle('calendar-event-completed', !isTimeOff && status === 'completed');
            eventNode.classList.toggle('calendar-event-timeoff', isTimeOff);
            eventNode.style.top = `${top}%`;
            eventNode.style.height = `${height}%`;

            const title = eventNode.querySelector('.calendar-event-title');
            if (isTimeOff) {
                title.textContent = (event.title || 'Personal Time');
            } else {
                title.textContent = event.client_name ? `${event.client_name} ${event.client_last_name || ''}`.trim() : event.client_username;
            }

            const timeEl = eventNode.querySelector('.calendar-event-time');
            timeEl.textContent = `${formatTime(start)} – ${formatTime(end)}`;

            const dragZone = eventNode.querySelector('.calendar-event-dragzone');
            if (dragZone) {
                dragZone.addEventListener('pointerdown', (evt) => handleDragPointerDown(evt, event, column));
                if (isTimeOff) {
                    const existingTypeIcon = dragZone.querySelector('.calendar-event-typeicon');
                    if (!existingTypeIcon) {
                        const indicator = document.createElement('i');
                        indicator.className = 'bi bi-umbrella-fill calendar-event-typeicon';
                        dragZone.insertBefore(indicator, dragZone.querySelector('.calendar-event-dragtext'));
                    }
                }
            }
            const dragText = eventNode.querySelector('.calendar-event-dragtext');
            if (dragText) {
                dragText.textContent = STATUS_LABELS[status] || (isTimeOff ? 'Personal Time' : 'Booked');
            }
            const contentArea = eventNode.querySelector('.calendar-event-content');
            if (contentArea) {
                contentArea.addEventListener('click', (evt) => handleEventClick(evt, event));
            }
            const topHandle = eventNode.querySelector('.calendar-event-handle-top');
            const bottomHandle = eventNode.querySelector('.calendar-event-handle-bottom');
            if (topHandle) {
                topHandle.addEventListener('pointerdown', (evt) => beginResize(evt, event, column, 'top'));
            }
            if (bottomHandle) {
                bottomHandle.addEventListener('pointerdown', (evt) => beginResize(evt, event, column, 'bottom'));
            }

            column.appendChild(eventNode);
        });
    }

    function formatTime(date) {
        return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
    }

    function rangesOverlap(startA, endA, startB, endB) {
        return startA < endB && endA > startB;
    }

    function fetchEvents() {
        const startIso = toISODate(state.weekStart);
        const end = new Date(state.weekStart);
        end.setDate(end.getDate() + 7);
        const endIso = toISODate(end);
        fetch(`/trainer/schedule/data?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(endIso)}`)
            .then(res => res.json())
            .then(data => {
                if (!data.success) throw new Error(data.error || 'Failed to load schedule.');
                const incoming = Array.isArray(data.events) ? data.events.map(ev => {
                    const normalized = { ...ev };
                    normalized.type = ev.type || (ev.status === 'time_off' ? 'time_off' : 'session');
                    if (normalized.type === 'time_off') {
                        normalized.status = 'time_off';
                        normalized.title = normalized.title || 'Personal Time';
                    } else {
                        normalized.status = (normalized.status || 'booked').toLowerCase();
                    }
                    return normalized;
                }) : [];
                state.events = incoming;
                sortEvents();
                renderEvents();
                if (state.modalEvent) {
                    const refreshed = state.events.find(ev =>
                        ev.id === state.modalEvent.id &&
                        (ev.type || 'session') === (state.modalEvent.type || 'session')
                    );
                    if (refreshed) {
                        const repeatInfo = state.modalEvent.repeatInfo;
                        state.modalEvent = {
                            ...refreshed,
                            status: refreshed.type === 'time_off'
                                ? 'time_off'
                                : (refreshed.status || 'booked').toLowerCase(),
                            repeatInfo
                        };
                        refreshModalFromState();
                    } else {
                        closeEventModal();
                    }
                }
            })
            .catch(err => {
                console.error(err);
                emptyState.hidden = false;
                emptyState.textContent = 'Unable to load schedule.';
                showDashboardToast('Unable to load schedule.', 'danger');
            });
    }

    function selectClient(button) {
        bookButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        const name = button.dataset.clientName || 'Client';
        const last = button.dataset.clientLastname || '';
        const fullName = `${name} ${last}`.trim();
        setSelectedClientDisplay(`Booking for ${fullName}`, false);
        const sessionsTotal = button.dataset.sessions === '' ? null : Number(button.dataset.sessions);
        const sessionsBooked = Number(button.dataset.sessionsBooked || '0');
        const sessionsCompleted = Number(button.dataset.sessionsCompleted || '0');
        const workoutsCompleted = Number(button.dataset.workoutsCompleted || '0');
        state.selectedClient = {
            id: Number(button.dataset.clientId),
            name,
            last,
            sessions: sessionsTotal,
            sessionsBooked,
            sessionsCompleted,
            workoutsCompleted
        };
        state.selectedClientButton = button;
        const consumed = (state.selectedClient.sessionsBooked || 0) + (state.selectedClient.sessionsCompleted || 0);
        if (state.selectedClient.sessions !== null && consumed >= state.selectedClient.sessions) {
            showDashboardToast(`${name} ${last} has no sessions remaining.`, 'danger');
            state.selectedClient = null;
            state.selectedClientButton = null;
            setSelectedClientDisplay('No client selected', true);
            bookButtons.forEach(btn => btn.classList.remove('active'));
            return;
        }
        calendarRoot.scrollIntoView({ behavior: 'smooth', block: 'start' });
        renderEvents();
    }

    function handleSlotClick(event) {
        const slot = event.target.closest('.calendar-slot');
        if (!slot) return;
        if (!state.selectedClient) {
            showDashboardToast('Select a client before booking a slot.', 'warning');
            return;
        }
        const consumed = (state.selectedClient.sessionsBooked || 0) + (state.selectedClient.sessionsCompleted || 0);
        if (state.selectedClient.sessions !== null && consumed >= state.selectedClient.sessions) {
            showDashboardToast('That client has no sessions remaining.', 'danger');
            state.selectedClient = null;
            state.selectedClientButton = null;
            setSelectedClientDisplay('No client selected', true);
            bookButtons.forEach(btn => btn.classList.remove('active'));
            return;
        }
        if (slot.classList.contains('calendar-slot-past')) {
            showDashboardToast('Pick a future time slot to book.', 'warning');
            return;
        }
        const start = new Date(slot.dataset.start);
        const end = new Date(start.getTime() + DEFAULT_DURATION * MILLI_IN_MINUTE);
        if (hasBlockingConflict(start, end, 'session')) {
            showDashboardToast('That time overlaps an existing session or personal time block.', 'danger');
            return;
        }
        createBooking(start, end);
    }

    function handleTimeOffSubmit(event) {
        if (event) event.preventDefault();
        if (!timeOffStartInput || !timeOffEndInput || !timeOffSubmit) return;
        const startValue = timeOffStartInput.value;
        const endValue = timeOffEndInput.value;
        if (!startValue || !endValue) {
            showDashboardToast('Select both a start and end time for personal time.', 'warning');
            return;
        }
        const startDate = new Date(startValue);
        const endDate = new Date(endValue);
        if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
            showDashboardToast('Enter valid start and end times.', 'warning');
            return;
        }
        if (startDate >= endDate) {
            showDashboardToast('End time must be after the start time.', 'warning');
            return;
        }
        if (startDate.toDateString() !== endDate.toDateString()) {
            showDashboardToast('Personal time blocks must start and end on the same day.', 'warning');
            return;
        }
        if ((startDate.getMinutes() % 15) !== 0 || (endDate.getMinutes() % 15) !== 0) {
            showDashboardToast('Times must be aligned to 15-minute increments.', 'warning');
            return;
        }
        const windowStartMinutes = state.viewStart * 60;
        const windowEndMinutes = state.viewEnd * 60;
        const blockStartMinutes = startDate.getHours() * 60 + startDate.getMinutes();
        const blockEndMinutes = endDate.getHours() * 60 + endDate.getMinutes();
        if (blockStartMinutes < windowStartMinutes || blockEndMinutes > windowEndMinutes) {
            showDashboardToast('Personal time must stay within your visible availability window.', 'warning');
            return;
        }

        if (hasBlockingConflict(startDate, endDate, 'time_off')) {
            showDashboardToast('That window overlaps an existing session or personal time block.', 'danger');
            return;
        }

        timeOffSubmit.disabled = true;
        timeOffSubmit.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Saving...';

        fetch('/trainer/time-off', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                start_time: startDate.toISOString(),
                end_time: endDate.toISOString()
            })
        })
            .then(res => res.json())
            .then(data => {
                if (!data.success) {
                    showDashboardToast(data.error || 'Unable to add personal time.', 'danger');
                    return;
                }
                if (data.block) {
                    upsertEvent(data.block);
                    sortEvents();
                    renderEvents();
                }
                timeOffForm?.reset();
                showDashboardToast('Personal time blocked.', 'success');
                fetchEvents();
            })
            .catch(() => {
                showDashboardToast('Network error adding personal time.', 'danger');
            })
            .finally(() => {
                if (timeOffSubmit) {
                    timeOffSubmit.disabled = false;
                    timeOffSubmit.innerHTML = '<i class="bi bi-calendar-plus me-1"></i>Block Personal Time';
                }
            });
    }

    function createBooking(startDate, endDate) {
        const payload = {
            client_id: state.selectedClient.id,
            start_time: startDate.toISOString(),
            end_time: endDate.toISOString(),
            duration_minutes: (endDate - startDate) / MILLI_IN_MINUTE
        };
        fetch('/trainer/schedule/book', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
            .then(async res => {
                let data = {};
                try {
                    data = await res.json();
                } catch (_) {}
                if (!res.ok || !data.success) {
                    const message = data.error || 'Unable to book that slot.';
                    showDashboardToast(message, 'danger');
                    return;
                }
                upsertEvent(data.event);
                sortEvents();
                renderEvents();
                const resultClientId = data.event?.client_id || (state.selectedClient ? state.selectedClient.id : null);
                if (typeof data.sessions_booked !== 'undefined' || typeof data.sessions_remaining !== 'undefined' || typeof data.sessions_completed !== 'undefined') {
                    if (resultClientId) {
                        syncClientSessionCounts(resultClientId, {
                            sessions_booked: data.sessions_booked,
                            sessions_remaining: data.sessions_remaining,
                            sessions_completed: data.sessions_completed,
                            workouts_completed: data.workouts_completed
                        });
                    }
                } else if (state.selectedClient) {
                    const updatedBooked = (state.selectedClient.sessionsBooked || 0) + 1;
                    syncClientSessionCounts(state.selectedClient.id, {
                        sessions_booked: updatedBooked,
                        sessions_remaining: state.selectedClient.sessions,
                        sessions_completed: state.selectedClient.sessionsCompleted || 0,
                        workouts_completed: state.selectedClient.workoutsCompleted || 0
                    });
                }
                showDashboardToast('Session booked!', 'success');
            })
            .catch(() => showDashboardToast('Unable to connect to the scheduler.', 'danger'));
    }

    function deleteEvent(eventId, eventType = 'session', options = {}) {
        const { skipConfirm = false } = options;
        if (!eventId) return Promise.resolve(false);
        const type = eventType || 'session';
        const isTimeOff = type === 'time_off';
        const promptMessage = isTimeOff ? 'Remove this personal time block?' : 'Remove this booking?';
        if (!skipConfirm && !confirm(promptMessage)) {
            return Promise.resolve(false);
        }
        const key = `${type}:${eventId}`;
        const target = state.events.find(ev => eventKey(ev) === key);

        if (isTimeOff) {
            return fetch(`/trainer/time-off/${eventId}`, { method: 'DELETE' })
                .then(res => res.json())
                .then(data => {
                    if (!data.success) {
                        showDashboardToast(data.error || 'Unable to remove that personal time block.', 'danger');
                        return false;
                    }
                    state.events = state.events.filter(ev => eventKey(ev) !== key);
                    renderEvents();
                    showDashboardToast('Personal time block removed.', 'success');
                    return true;
                })
                .catch(() => {
                    showDashboardToast('Network issue deleting personal time block.', 'danger');
                    return false;
                });
        }

        const targetClientId = target ? target.client_id : null;
        const wasBooked = (target?.status || 'booked').toLowerCase() === 'booked';

        return fetch(`/trainer/schedule/${eventId}`, { method: 'DELETE' })
            .then(res => res.json())
            .then(data => {
                if (!data.success) {
                    showDashboardToast(data.error || 'Unable to remove booking.', 'danger');
                    return false;
                }
                state.events = state.events.filter(ev => eventKey(ev) !== key);
                renderEvents();
                if (targetClientId && wasBooked) {
                    let newBooked = null;
                    let totalSessions = null;
                    let completedSessions = 0;
                    let workoutsCompleted = 0;
                    let buttonRef = null;
                    if (state.selectedClient && state.selectedClient.id === targetClientId) {
                        newBooked = Math.max((state.selectedClient.sessionsBooked || 1) - 1, 0);
                        totalSessions = state.selectedClient.sessions;
                        completedSessions = state.selectedClient.sessionsCompleted || 0;
                        workoutsCompleted = state.selectedClient.workoutsCompleted || 0;
                    } else {
                        buttonRef = document.querySelector(`.book-client-btn[data-client-id="${targetClientId}"]`);
                        if (buttonRef) {
                            newBooked = Math.max(Number(buttonRef.dataset.sessionsBooked || '0') - 1, 0);
                            totalSessions = buttonRef.dataset.sessions === '' ? null : Number(buttonRef.dataset.sessions || '0');
                            completedSessions = Number(buttonRef.dataset.sessionsCompleted || '0');
                            workoutsCompleted = Number(buttonRef.dataset.workoutsCompleted || '0');
                        }
                    }
                    if (newBooked !== null) {
                        syncClientSessionCounts(targetClientId, {
                            sessions_booked: newBooked,
                            sessions_remaining: totalSessions,
                            sessions_completed: completedSessions,
                            workouts_completed: workoutsCompleted
                        });
                    }
                }
                showDashboardToast('Booking removed.', 'success');
                return true;
            })
            .catch(() => {
                showDashboardToast('Network issue deleting booking.', 'danger');
                return false;
            });
    }

    function handleRepeatSubmit(event) {
        if (event) event.preventDefault();
        if (!state.modalEvent || !eventRepeatWeeksInput || !eventRepeatSubmit) return;
        const eventType = state.modalEvent.type || 'session';
        const isTimeOff = eventType === 'time_off';
        const weeksValue = Number(eventRepeatWeeksInput.value || '0');
        if (!Number.isInteger(weeksValue) || weeksValue <= 0) {
            showDashboardToast('Enter how many weeks you would like to repeat.', 'warning');
            return;
        }
        if (weeksValue > 52) {
            showDashboardToast('You can repeat up to 52 weeks at a time.', 'warning');
            return;
        }
        const entityLabel = isTimeOff ? 'personal time block' : 'session';
        const confirmation = window.confirm(`Repeat this ${entityLabel} for ${weeksValue} week${weeksValue === 1 ? '' : 's'}?`);
        if (!confirmation) {
            return;
        }
        eventRepeatSubmit.disabled = true;
        eventRepeatSubmit.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Repeating...';

        const endpoint = isTimeOff
            ? `/trainer/time-off/${state.modalEvent.id}/repeat`
            : `/trainer/schedule/${state.modalEvent.id}/repeat`;

        fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ weeks: weeksValue })
        })
            .then(res => res.json())
            .then(data => {
                if (!data.success) {
                    const errorMessage = data.error || (isTimeOff ? 'Unable to repeat that personal time block.' : 'Unable to repeat that booking.');
                    showDashboardToast(errorMessage, 'danger');
                    if (eventRepeatInfo && Array.isArray(data.conflicts) && data.conflicts.length > 0) {
                        const skippedMessage = `Skipped ${data.conflicts.length} week(s) due to conflicts.`;
                        eventRepeatInfo.textContent = skippedMessage;
                        if (state.modalEvent) {
                            state.modalEvent.repeatInfo = skippedMessage;
                        }
                    }
                    return;
                }
                const createdItems = isTimeOff ? data.created_blocks : data.created_events;
                if (Array.isArray(createdItems)) {
                    createdItems.forEach(ev => upsertEvent(ev));
                    sortEvents();
                    renderEvents();
                }
                if (eventRepeatInfo) {
                    let infoMessage = '';
                    if (Array.isArray(data.conflicts) && data.conflicts.length > 0) {
                        infoMessage = `Added ${data.created_count} ${isTimeOff ? 'personal time block' : 'session'}${data.created_count === 1 ? '' : 's'}; ${data.conflicts.length} week(s) skipped because of conflicts.`;
                    } else if (!isTimeOff && data.remaining_quota === 0 && data.sessions_remaining !== null) {
                        infoMessage = 'All available sessions are now booked.';
                    } else {
                        infoMessage = `Added ${data.created_count} weekly ${isTimeOff ? 'personal time block' : 'session'}${data.created_count === 1 ? '' : 's'}.`;
                    }
                    eventRepeatInfo.textContent = infoMessage;
                    if (state.modalEvent) {
                        state.modalEvent.repeatInfo = infoMessage;
                    }
                }
                if (eventRepeatWeeksInput) {
                    eventRepeatWeeksInput.value = '';
                }
                if (!isTimeOff && (data.sessions_booked !== undefined || data.sessions_remaining !== undefined || data.sessions_completed !== undefined)) {
                    syncClientSessionCounts(state.modalEvent.client_id, {
                        sessions_booked: data.sessions_booked,
                        sessions_remaining: data.sessions_remaining,
                        sessions_completed: data.sessions_completed,
                        workouts_completed: data.workouts_completed
                    });
                }
                showDashboardToast(
                    `Added ${data.created_count} weekly ${isTimeOff ? 'personal time block' : 'session'}${data.created_count === 1 ? '' : 's'}.`,
                    'success'
                );
                state.justDragged = false;
                closeEventModal();
                if (calendarRoot) {
                    calendarRoot.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            })
            .catch(() => showDashboardToast('Unable to repeat that booking right now.', 'danger'))
            .finally(() => {
                if (eventRepeatSubmit) {
                    eventRepeatSubmit.disabled = false;
                    eventRepeatSubmit.innerHTML = eventRepeatSubmitDefault;
                }
                fetchEvents();
            });
    }

    function handleStatusUpdate(event) {
        if (event) event.preventDefault();
        if (!state.modalEvent || !eventStatusSelect || !eventStatusUpdate) return;
        if ((state.modalEvent.type || 'session') === 'time_off') {
            showDashboardToast('Personal time blocks do not have statuses.', 'info');
            return;
        }
        const desired = (eventStatusSelect.value || '').trim().toLowerCase();
        if (!desired) {
            showDashboardToast('Select a status to apply.', 'warning');
            return;
        }
        const currentStatus = (state.modalEvent.status || 'booked').toLowerCase();
        if (desired === currentStatus) {
            showDashboardToast('Session already has that status.', 'info');
            return;
        }
        eventStatusUpdate.disabled = true;
        eventStatusUpdate.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Applying...';
        fetch(`/trainer/schedule/${state.modalEvent.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: desired })
        })
            .then(res => res.json())
            .then(data => {
                if (!data.success) {
                    showDashboardToast(data.error || 'Unable to update session status.', 'danger');
                    if (eventStatusUpdate) {
                        eventStatusUpdate.disabled = false;
                        eventStatusUpdate.innerHTML = eventStatusUpdateDefault;
                    }
                    return;
                }
                const updatedEvent = data.event;
                const newStatus = (updatedEvent.status || desired).toLowerCase();
                const clientId = updatedEvent.client_id;

                upsertEvent(updatedEvent);
                sortEvents();
                renderEvents();

                const priorRepeatInfo = state.modalEvent ? state.modalEvent.repeatInfo : undefined;
                state.modalEvent = {
                    ...updatedEvent,
                    status: newStatus,
                    repeatInfo: priorRepeatInfo
                };
                refreshModalFromState();

                if (typeof data.sessions_booked !== 'undefined' || typeof data.sessions_remaining !== 'undefined' || typeof data.sessions_completed !== 'undefined') {
                    syncClientSessionCounts(clientId, {
                        sessions_booked: data.sessions_booked,
                        sessions_remaining: data.sessions_remaining,
                        sessions_completed: data.sessions_completed,
                        workouts_completed: data.workouts_completed
                    });
                } else {
                    let delta = 0;
                    if (currentStatus === 'booked' && newStatus !== 'booked') delta = -1;
                    if (currentStatus !== 'booked' && newStatus === 'booked') delta = 1;
                    if (delta !== 0) {
                        if (state.selectedClient && state.selectedClient.id === clientId) {
                            const updated = Math.max((state.selectedClient.sessionsBooked || 0) + delta, 0);
                            syncClientSessionCounts(clientId, {
                                sessions_booked: updated,
                                sessions_remaining: state.selectedClient.sessions,
                                sessions_completed: state.selectedClient.sessionsCompleted || 0,
                                workouts_completed: state.selectedClient.workoutsCompleted || 0
                            });
                        } else {
                            const btn = document.querySelector(`.book-client-btn[data-client-id="${clientId}"]`);
                            if (btn) {
                                const currentBooked = Math.max(Number(btn.dataset.sessionsBooked || '0') + delta, 0);
                                const totalSessions = btn.dataset.sessions === '' ? null : Number(btn.dataset.sessions || '0');
                                const completedSessions = Number(btn.dataset.sessionsCompleted || '0');
                                syncClientSessionCounts(clientId, {
                                    sessions_booked: currentBooked,
                                    sessions_remaining: totalSessions,
                                    sessions_completed: completedSessions,
                                    workouts_completed: Number(btn.dataset.workoutsCompleted || '0')
                                });
                            }
                        }
                    }
                }
                showDashboardToast(`Status updated to ${STATUS_LABELS[newStatus] || newStatus}.`, 'success');
                closeEventModal();
            })
            .catch(() => {
                showDashboardToast('Unable to update session status right now.', 'danger');
            })
            .finally(() => {
                if (eventStatusUpdate) {
                    eventStatusUpdate.disabled = false;
                    eventStatusUpdate.innerHTML = eventStatusUpdateDefault;
                }
                fetchEvents();
            });
    }

    function handleDeleteEntry() {
        if (!state.modalEvent || !eventDeleteSession || eventDeleteSession.disabled) return;
        const eventType = state.modalEvent.type || 'session';
        const isTimeOff = eventType === 'time_off';
        const confirmMessage = isTimeOff ? 'Delete this personal time block?' : 'Delete this session permanently?';
        if (!confirm(confirmMessage)) return;
        eventDeleteSession.disabled = true;
        eventDeleteSession.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Deleting...';
        const targetId = state.modalEvent.id;
        deleteEvent(targetId, eventType, { skipConfirm: true })
            .then(success => {
                if (success) {
                    fetchEvents();
                    closeEventModal();
                } else if (eventDeleteSession) {
                    eventDeleteSession.disabled = false;
                    eventDeleteSession.innerHTML = eventDeleteDefault;
                }
            });
    }

    function beginDrag(evt, eventData, column) {
        if (evt.target.closest('.calendar-event-handle')) return;
        evt.preventDefault();
        const rect = column.getBoundingClientRect();
        const columnIndex = dayColumns.indexOf(column);
        const eventElement = columnsEl.querySelector(`.calendar-event[data-id="${eventData.id}"][data-type="${getEntryType(eventData)}"]`);
        if (eventElement) {
            eventElement.classList.add('calendar-event--dragging');
        }
        state.dragging = {
            type: 'move',
            id: eventData.id,
            entryType: eventData.type || (eventData.status === 'time_off' ? 'time_off' : 'session'),
            entryKey: eventKey(eventData),
            column,
            columnIndex,
            currentColumnIndex: columnIndex,
            startY: evt.clientY,
            startX: evt.clientX,
            rect,
            initialWidth: rect.width || 1,
            originalStart: new Date(eventData.start_time),
            originalEnd: new Date(eventData.end_time),
            element: eventElement
        };
        setPointerCapture(evt, evt.currentTarget || evt.target);
    }

    function beginResize(evt, eventData, column, direction) {
        const pointerType = evt.pointerType || (evt.type && evt.type.startsWith('mouse') ? 'mouse' : 'touch');
        if (pointerType !== 'mouse') {
            return;
        }
        evt.preventDefault();
        const rect = column.getBoundingClientRect();
        const columnIndex = dayColumns.indexOf(column);
        state.dragging = {
            type: direction === 'top' ? 'resize-start' : 'resize-end',
            id: eventData.id,
            entryType: eventData.type || (eventData.status === 'time_off' ? 'time_off' : 'session'),
            entryKey: eventKey(eventData),
            column,
            columnIndex,
            currentColumnIndex: columnIndex,
            startY: evt.clientY,
            startX: evt.clientX,
            rect,
            initialWidth: rect.width || 1,
            originalStart: new Date(eventData.start_time),
            originalEnd: new Date(eventData.end_time),
            element: null
        };
        setPointerCapture(evt, evt.currentTarget || evt.target);
    }

    function setPointerCapture(evt, target) {
        const captureTarget = target || evt.target;
        state.dragPointer = { target: captureTarget, id: evt.pointerId };
        if (captureTarget.setPointerCapture) {
            try { captureTarget.setPointerCapture(evt.pointerId); } catch (_) {}
        }
        document.addEventListener('pointermove', handlePointerMove);
        document.addEventListener('pointerup', handlePointerUp, { once: true });
        document.addEventListener('pointercancel', handlePointerUp, { once: true });
    }

    function handlePointerMove(evt) {
        if (!state.dragging) return;
        const { type: action, originalStart, originalEnd, columnIndex, initialWidth, entryType } = state.dragging;
        let currentColumnIndex = state.dragging.currentColumnIndex;
        const deltaY = evt.clientY - state.dragging.startY;
        const totalMinutes = (state.viewEnd - state.viewStart) * 60;

        if (action === 'move' && initialWidth) {
            const deltaX = evt.clientX - state.dragging.startX;
            const rawDayDelta = Math.round(deltaX / initialWidth);
            let targetIndex = columnIndex + rawDayDelta;
            targetIndex = Math.max(0, Math.min(dayColumns.length - 1, targetIndex));
            if (targetIndex !== currentColumnIndex) {
                const eventElement = columnsEl.querySelector(`.calendar-event[data-id="${state.dragging.id}"][data-type="${entryType}"]`);
                if (eventElement && dayColumns[targetIndex]) {
                    dayColumns[targetIndex].appendChild(eventElement);
                    state.dragging.currentColumnIndex = targetIndex;
                    const newRect = dayColumns[targetIndex].getBoundingClientRect();
                    state.dragging.rect = newRect;
                    state.dragging.initialWidth = newRect.width || state.dragging.initialWidth;
                    state.dragging.column = dayColumns[targetIndex];
                }
                currentColumnIndex = targetIndex;
            }
        }

        const column = dayColumns[currentColumnIndex];
        if (!column) return;
        const columnRect = column.getBoundingClientRect();
        const minutesPerPixel = totalMinutes / (columnRect.height || 1);
        const offsetMinutes = Math.round(deltaY * minutesPerPixel / FIFTEEN_MINUTES) * FIFTEEN_MINUTES;

        const effectiveDayDelta = state.dragging.currentColumnIndex - columnIndex;
        let newStart = new Date(originalStart.getTime() + (offsetMinutes + effectiveDayDelta * 1440) * MILLI_IN_MINUTE);
        let newEnd = new Date(originalEnd.getTime() + (offsetMinutes + effectiveDayDelta * 1440) * MILLI_IN_MINUTE);

        const minMinutes = FIFTEEN_MINUTES;
        if ((newEnd - newStart) / MILLI_IN_MINUTE < minMinutes) return;

        const eventElement = columnsEl.querySelector(`.calendar-event[data-id="${state.dragging.id}"][data-type="${entryType}"]`);
        if (!eventElement) return;

        const durationMinutes = (newEnd - newStart) / MILLI_IN_MINUTE;
        const startMinutesRelative = (newStart.getHours() - state.viewStart) * 60 + newStart.getMinutes();
        let visibleStart = Math.max(0, startMinutesRelative);
        const maxStart = totalMinutes - durationMinutes;
        visibleStart = Math.min(maxStart, visibleStart);
        const adjustment = visibleStart - startMinutesRelative;
        if (adjustment !== 0) {
            newStart = new Date(newStart.getTime() + adjustment * MILLI_IN_MINUTE);
            newEnd = new Date(newEnd.getTime() + adjustment * MILLI_IN_MINUTE);
        }

        const visibleEnd = Math.min(totalMinutes, visibleStart + durationMinutes);
        const top = (visibleStart / totalMinutes) * 100;
        const height = Math.max((visibleEnd - visibleStart) / totalMinutes * 100, 2);
        eventElement.style.top = `${top}%`;
        eventElement.style.height = `${height}%`;
        eventElement.querySelector('.calendar-event-time').textContent = `${formatTime(newStart)} – ${formatTime(newEnd)}`;

        state.dragging.previewStart = newStart;
        state.dragging.previewEnd = newEnd;
    }

    function handlePointerUp() {
        document.removeEventListener('pointermove', handlePointerMove);
        const dragPointer = state.dragPointer;
        if (dragPointer && dragPointer.target && dragPointer.target.releasePointerCapture) {
            try { dragPointer.target.releasePointerCapture(dragPointer.id); } catch (_) {}
        }
        state.dragPointer = null;
        if (!state.dragging) return;
        const dragMeta = state.dragging;
        const { previewStart, previewEnd, id, entryType, entryKey, element } = dragMeta;
        if (element) {
            element.classList.remove('calendar-event--dragging');
        }
        const hadPreview = Boolean(previewStart && previewEnd);
        state.dragging = null;
        if (!hadPreview) {
            state.justDragged = false;
            renderEvents();
            return;
        }
        if (hasBlockingConflict(previewStart, previewEnd, entryType, entryKey)) {
            renderEvents();
            const overlapMessage = entryType === 'time_off'
                ? 'Personal time cannot overlap sessions or other personal time blocks.'
                : 'Sessions cannot overlap other sessions or personal time blocks.';
            showDashboardToast(overlapMessage, 'danger');
            return;
        }
        state.justDragged = true;
        setTimeout(() => {
            state.justDragged = false;
        }, 150);
        const endpoint = entryType === 'time_off' ? `/trainer/time-off/${id}` : `/trainer/schedule/${id}`;
        fetch(endpoint, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                start_time: previewStart.toISOString(),
                end_time: previewEnd.toISOString()
            })
        })
            .then(res => res.json())
            .then(data => {
                if (!data.success) {
                    const errorMessage = data.error || (entryType === 'time_off'
                        ? 'Unable to update personal time block.'
                        : 'Unable to update booking.');
                    showDashboardToast(errorMessage, 'danger');
                    fetchEvents();
                    return;
                }
                const payload = entryType === 'time_off' ? data.block : data.event;
                if (!payload) {
                    fetchEvents();
                    return;
                }
                upsertEvent(payload);
                sortEvents();
                renderEvents();
                const successMessage = entryType === 'time_off' ? 'Personal time updated.' : 'Booking updated.';
                showDashboardToast(successMessage, 'success');
            })
            .catch(() => {
                const networkMessage = entryType === 'time_off'
                    ? 'Network error updating personal time block.'
                    : 'Network error updating booking.';
                showDashboardToast(networkMessage, 'danger');
                fetchEvents();
            });
    }

    function openWindowModal() {
        windowStartInput.value = `${String(state.viewStart).padStart(2, '0')}:00`;
        windowEndInput.value = `${String(state.viewEnd).padStart(2, '0')}:00`;
        windowModal.hidden = false;
    }

    function closeWindowModal() {
        windowModal.hidden = true;
    }

    function applyWindow(event) {
        event.preventDefault();
        const startValue = (windowStartInput.value || '05:00').split(':')[0];
        const endValue = (windowEndInput.value || '21:00').split(':')[0];
        const start = clampHour(parseInt(startValue, 10));
        const end = clampHour(parseInt(endValue, 10));
        if (end <= start) {
            showDashboardToast('End hour must be after start hour.', 'danger');
            return;
        }
        state.viewStart = start;
        state.viewEnd = end;
        closeWindowModal();
        rebuildGrid();
        renderEvents();
        saveWindowPreference(start, end);
    }

    function saveWindowPreference(start, end) {
        fetch('/trainer/schedule/preferences', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ view_start: start, view_end: end })
        })
            .then(res => res.json())
            .then(data => {
                if (!data.success) {
                    showDashboardToast(data.error || 'Unable to save availability window.', 'danger');
                    return;
                }
                showDashboardToast('Availability window saved.', 'success');
                calendarRoot.dataset.viewStart = String(data.view_start);
                calendarRoot.dataset.viewEnd = String(data.view_end);
            })
            .catch(() => showDashboardToast('Network error saving availability window.', 'danger'));
    }

    function rebuildGrid() {
        renderHeaders();
        renderTimes();
        renderSlots();
        const scrollWrap = document.getElementById('calendar-scroll');
        if (scrollWrap) scrollWrap.scrollLeft = 0;
    }

    function applyInitialFocus() {
        if (typeof window === 'undefined') return;
        const params = new URLSearchParams(window.location.search);
        const focusParam = params.get('focus');
        if (!focusParam || !focusParam.startsWith('client-')) return;
        const numeric = Number(focusParam.replace('client-', ''));
        if (!Number.isFinite(numeric) || numeric <= 0) return;
        const targetBtn = document.querySelector(`.book-client-btn[data-client-id="${numeric}"]`);
        if (!targetBtn) return;
        selectClient(targetBtn);
        const action = (params.get('action') || '').toLowerCase();
        if (action === 'book') {
            showDashboardToast('Select a time slot to add this client to the schedule.', 'info');
            setTimeout(() => {
                if (calendarRoot) {
                    calendarRoot.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 250);
        }
        params.delete('focus');
        params.delete('action');
        const query = params.toString();
        const newUrl = query ? `${window.location.pathname}?${query}${window.location.hash}` : `${window.location.pathname}${window.location.hash}`;
        history.replaceState({}, document.title, newUrl);
    }

    function init() {
        rebuildGrid();
        updateWeekLabel();
        fetchEvents();

        bookButtons.forEach(btn => {
            btn.addEventListener('click', () => selectClient(btn));
        });

        prevWeekBtn.addEventListener('click', () => {
            state.weekStart.setDate(state.weekStart.getDate() - 7);
            rebuildGrid();
            updateWeekLabel();
            fetchEvents();
        });
        nextWeekBtn.addEventListener('click', () => {
            state.weekStart.setDate(state.weekStart.getDate() + 7);
            rebuildGrid();
            updateWeekLabel();
            fetchEvents();
        });
        todayBtn.addEventListener('click', () => {
            state.weekStart = startOfWeek(new Date());
            rebuildGrid();
            updateWeekLabel();
            fetchEvents();
        });

        if (viewToggleFocused) {
            viewToggleFocused.addEventListener('change', () => {
                if (viewToggleFocused.checked) {
                    applyViewMode('focused');
                }
            });
        }
        if (viewToggleFull) {
            viewToggleFull.addEventListener('change', () => {
                if (viewToggleFull.checked) {
                    applyViewMode('full');
                }
            });
        }

        editWindowBtn.addEventListener('click', openWindowModal);
        windowModalClose.addEventListener('click', closeWindowModal);
        windowCancel.addEventListener('click', closeWindowModal);
        windowForm.addEventListener('submit', applyWindow);

        if (eventModalClose) {
            eventModalClose.addEventListener('click', closeEventModal);
        }
        if (eventModal) {
            eventModal.addEventListener('click', (evt) => {
                if (evt.target === eventModal) {
                    closeEventModal();
                }
            });
        }
        if (eventRepeatForm) {
            eventRepeatForm.addEventListener('submit', handleRepeatSubmit);
        }
        if (eventStatusForm) {
            eventStatusForm.addEventListener('submit', handleStatusUpdate);
        }
        if (eventDeleteSession) {
            eventDeleteSession.addEventListener('click', handleDeleteEntry);
        }
        if (timeOffForm) {
            timeOffForm.addEventListener('submit', handleTimeOffSubmit);
        }
        if (typeof document !== 'undefined') {
            document.addEventListener('keydown', (evt) => {
                if (evt.key === 'Escape' && state.modalEvent && eventModal && !eventModal.hidden) {
                    closeEventModal();
                }
            });
        }

        columnsEl.addEventListener('click', handleSlotClick);
    }

    init();
    applyInitialFocus();
})();
</script>
{% endblock %}
